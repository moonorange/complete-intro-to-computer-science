{"componentChunkName":"component---src-templates-lesson-template-js","path":"/binary-search-tree","result":{"data":{"markdownRemark":{"html":"<p>Trees are another way to structure data. They work differently that arrays so we won't be looking at the exact same thing but they have their own uses. Arrays can have arbitrary data in arbitrary order. An array of <code class=\"language-text\">[1, 5, 2, 7, 3]</code> is totally fine: it doesn't have to be in a sorted order. The kind of trees we're going to be looking at today are all ordered by value, so whenever you insert a new value, it will be inserted in a sorted fashion e.g. if we add 5 to <code class=\"language-text\">[1, 4, 6, 7]</code> it <em>must</em> be inserted between the 4 and the 6.</p>\n<p>There are <em>many</em> varieties of tree data structures. We'll be looking at two of them today, binary search trees and AVL trees, but there are so many more. They're used everywhere due to their fast access patterns, even across enormous data sets.</p>\n<p>At its core, a tree is very similar to a LinkedList. You have nodes. Those nodes have values and pointers to other nodes. Unlike a LinkedList which only has one next pointer (or maybe a next and previous) trees can have many pointers. We're going to be looking at two types of trees today that have just two children nodes: binary search trees and AVL trees (which are a special type of binary search tree).</p>\n<p>The first one we'll be looking at is a binary search tree (from here-on-out I'll abbreviate binary search trees as BSTs.) The binary part means there are at most two children nodes per node and the search part means that it's particularly well suited for \"search\" scenarios e.g. you need to be able to rapidly access data in it, even if it means slower inserts and deletes.</p>\n<p>So we have one node that is the root. That node can have a left child and a right child. It can have both, one, or neither. Every node has a value. Both children are nodes just like the root: they can 0-2 children as well and will always have a value (there are no nodes without values.) Every value in a node's left tree is smaller than its value and every node in its right tree is larger than its value. Values that are equal can go either way, just be consistent. I tend to put equal values on the left.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 576px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/533c1/bst.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABTklEQVQ4y6WUW0vDQBCFv6a1GlQwrbR4qZdIjde2Vk2hWjXgi30QfJH+/18iW87CGuIu1IFlyWZycuacmYVwbAAXwCUQ84+oae8CV0AOHJTerRQ3wBiYAINVANaACGir1BaQaLWcM8OyGQIziUMx+ga2K3K2gAXwAIyAPR/gsXQaimFZr0i7ASmAKfBUpWvNSZxo7XoMMCwfgVcg9RmVqsxEbH1RVxudVb00pcyAU+fsWq0SapEO8A407MER0Afm7qHK+hCD/QDoXO4vqzoUs45KtbEDZBI+9TBtSM97AS/Bco1W5CQ21RovwPkfwtvnQqC3VtxN7eU/9yV85ik3kWzrJUK/3DPT8qVGR38uSqzqmvPP0LScaGZnumksizdJk6i1crk79vVhLMCRdLPT0pNpXZlo1rNaaxq6gXpyLHOSYo3jQO1kJLmTaW336x9DfhSEWbFJoQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary search tree\"\n        title=\"binary search tree\"\n        src=\"/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/533c1/bst.png\"\n        srcset=\"/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/772e8/bst.png 200w,\n/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/e17e5/bst.png 400w,\n/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/533c1/bst.png 576w\"\n        sizes=\"(max-width: 576px) 100vw, 576px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><sup>Public domain, via Wikimedia Commons</sup></p>\n<p>If the any of the above rules are violated, then your tree isn't a binary search tree. All of them use be followed 100% of the time. Because of this you can make assumptions about it which it makes really fast to use in certain scenarios. We'll talk about that in a bit.</p>\n<h2 id=\"look-ups\" style=\"position:relative;\"><a href=\"#look-ups\" aria-label=\"look ups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Look Ups</h2>\n<p>Let's talk about about how to do a look up. Say you have the above tree and you want to find 4.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-&gt; .find is called with 4\n-&gt; start with root 8, 4 is smaller so go left\n-&gt; node 3, 4 is larger, go right\n-&gt; node 6, 4 is smaller, go left\n-&gt; node 4, found result</code></pre></div>\n<p>This is the whole algorithm for look ups. Go left or right depending if it's smaller or bigger (respectively) and then you'll find it. What's the Big O here? In this case, we're not hopefully not looking at <em>every</em> item in the tree, just some small sampling of them. The average case here would be O(log n). The best case is that someone asks for the root which be O(1). The worst case if that if you have a poorly made BST where every child is on the left (or right) and you have to look at every item in the array to find it. That would be O(n).</p>\n<h2 id=\"add\" style=\"position:relative;\"><a href=\"#add\" aria-label=\"add permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Add</h2>\n<p>What if we want to add an element to the array? The good news is you just reuse the find method we defined above and when you find where the element <em>should</em> be, you just stick in a new item! Let's give it a shot.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Current Tree:\n      10\n    /   \\\n  5      15\n / \\     /\n3   8   12\n\n-&gt; .add is called with 7\n-&gt; start at root (10)\n-&gt; lesser than 10, go left to 5\n-&gt; greater than 5, go right to 8\n-&gt; lesser than 8, go left\n-&gt; no element at left, create new node\n   and make it the left subtree of 8\n\n         10\n       /   \\\n     5      15\n    / \\     /\n   3   8   12\n      /\n     7</code></pre></div>\n<h2 id=\"delete\" style=\"position:relative;\"><a href=\"#delete\" aria-label=\"delete permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Delete</h2>\n<p>Pretty similar to an add but a few additional steps. Let's take the tree</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">         10\n       /   \\\n     5      15\n    / \\    /  \\\n   3   8  12  17\n      /\n     6\n      \\\n       7</code></pre></div>\n<p>Let's say we want to delete 5. Obviously a node still has to exist there, and remember all nodes have values. So how do we delete 5 without fracturing all the assumptions of the BST? There are two ways: replace 5 with the smallest child in the right child's subtree or the greatest child in the left subtree. Let's do the former. What is the greatest child in the left subtree? Well, you just follow right children in the left subtree until you hit the last one. In this case, it's just 6, only one hop. But if 5.5 was there, you'd hop one more.</p>\n<p>Okay, so we found the least child in the right subtree. By definition, this node will not have a left child. Otherwise what you found wouldn't be the least one in this subtree. We're going to do two things: take its value and replace the value we're trying to delete (in this case 5) and then move 6's right child to node we're over writing's left child. Let's write that step-by-step.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-&gt; .delete called on 5\n-&gt; call .find on 5\n  -&gt; start with root, 10. 5 is less, go left\n  -&gt; found 5\n-&gt; .findLeastRightChild with 5\n  -&gt; go right on 5, land on 8\n  -&gt; go left as far as we can. only one hop, 6\n-&gt; replace the node that 5&#39;s value with 6\n   (the new 6 / old 5 node will be represented as 6&#39;)\n\n         10\n       /   \\\n     6&#39;     15\n    / \\    /  \\\n   3   8  12  17\n      /\n     6\n      \\\n       7\n\n-&gt; set 8 left child to be 6 right child\n\n         10\n       /   \\\n     6&#39;     15\n    / \\    /  \\\n   3   8  12  17\n      /\n     7</code></pre></div>\n<p>This is the most complicated scenario. Let's glance at the other two possibilities.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   10\n  /  \\\n 5   15\n\n-&gt; delete 15\n-&gt; it has no children (leaf node), set its parent right child to null\n\n   10\n  /\n 5</code></pre></div>\n<p>In this case you just wipe out the whole node when the node to delete is a leaf node.</p>\n<p>Okay, one more case.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   10\n  /  \\\n 5   15\n    /\n   12\n  /  \\\n 11  14\n\n-&gt; delete 15\n-&gt; 15 has no right child but does have a left child\n-&gt; set 10 right child to be 15 left child\n\n   10\n  /  \\\n 5   12\n    /  \\\n   11  14</code></pre></div>\n<p>When one of the children is null, you can just move its entire child to be the new child.</p>\n<p>The Big O of this would be still be O(log n). Despite it being more steps we don't normally need to look at every item in the tree.</p>\n<h2 id=\"worst-case-bsts\" style=\"position:relative;\"><a href=\"#worst-case-bsts\" aria-label=\"worst case bsts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Worst Case BSTs</h2>\n<p>Let's look at the worst case BST: if you have a sorted list of numbers and just added them in order.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5</code></pre></div>\n<p>Unfortunately a BST has no way to deal with this. This is why you'll never use BSTs directly yourself. There are variations of BST that are built to deal with these. We're going to look at one of them, the AVL tree, in the next section.</p>\n<h2 id=\"why-use-a-tree\" style=\"position:relative;\"><a href=\"#why-use-a-tree\" aria-label=\"why use a tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why Use a Tree</h2>\n<p>We went through a lot of trouble to learn about trees. Why would you ever use one? It's because they're very searchable. You're doing a bunch of work up front to make them easy to search later.</p>\n<p>One really good example that very frequently uses some variety of tree is database indexes. Let's say you have a database of all your orders and customers frequently search for their order by order number. We don't want to comb the whole database to find the one order: that'll be slow and taxing on your database. We also don't want to store the whole database in a tree: sometimes we want multiple indexes and we want to optimize the database so we can write quickly to it which keeping it in a tree would hinder.</p>\n<p>So we'll store the whole database in one data structure and then we'll keep a separate tree that we can use an index. When a user searches for their order number, we do a fast find on our tree, it points to where the item is in our database and we get a fast look up on a big database. O(log n) on large datasets is very fast.</p>\n<h2 id=\"exercises\" style=\"position:relative;\"><a href=\"#exercises\" aria-label=\"exercises permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exercises</h2>\n<p><a href=\"https://codesandbox.io/s/algorithms-exercises-8kdjr?file=/specs/bst/bst.test.js\"><img src=\"https://codesandbox.io/static/img/play-codesandbox.svg\" alt=\"Edit algorithms-exercises\"></a></p>\n<p>We're going to work on <a href=\"https://github.com/btholt/algorithms-exercises/blob/main/specs/bst/bst.test.js\">/specs/bst/bst.test.js</a>. Go give that a shot.</p>","frontmatter":{"path":"/binary-search-tree","title":"Binary Search Tree","order":"8A","section":"Trees","description":""}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"7A","path":"/arraylist","title":"ArrayList"}}},{"node":{"frontmatter":{"order":"8B","path":"/avl-tree","title":"AVL Tree"}}},{"node":{"frontmatter":{"order":"2A","path":"/big-o","title":"Big O"}}},{"node":{"frontmatter":{"order":"8A","path":"/binary-search-tree","title":"Binary Search Tree"}}},{"node":{"frontmatter":{"order":"6A","path":"/binary-search","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10A","path":"/bloom-filters","title":"Bloom Filters"}}},{"node":{"frontmatter":{"order":"8D","path":"/breadth-first-tree-traversals","title":"Breadth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"3A","path":"/bubble-sort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"8C","path":"/depth-first-tree-traversals","title":"Depth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"1B","path":"/exercises","title":"The Exercises"}}},{"node":{"frontmatter":{"order":"9A","path":"/graphs","title":"Graphs"}}},{"node":{"frontmatter":{"order":"8E","path":"/heap-sort","title":"Heap Sort"}}},{"node":{"frontmatter":{"order":"3B","path":"/insertion-sort","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"7B","path":"/linkedlist","title":"LinkedList"}}},{"node":{"frontmatter":{"order":"4B","path":"/merge-sort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"9B","path":"/pathfinding","title":"Pathfinding"}}},{"node":{"frontmatter":{"order":"4C","path":"/quick-sort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5A","path":"/radix-sort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"4A","path":"/recursion","title":"Recursion"}}},{"node":{"frontmatter":{"order":"2B","path":"/spatial-complexity","title":"Spatial Complexity"}}},{"node":{"frontmatter":{"order":"2C","path":"/trade-offs","title":"Trade Offs"}}},{"node":{"frontmatter":{"order":"9C","path":"/tries","title":"Tries"}}},{"node":{"frontmatter":{"order":"11A","path":"/wrap-up","title":"Wrap Up"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}