{"componentChunkName":"component---src-templates-lesson-template-js","path":"/bloom-filters","result":{"data":{"markdownRemark":{"html":"<p>Bloom filters are an interesting data structure which are designed to tell you quickly and efficiently if an item is in a set. If you need a reminder of what a set is, see the previous course. In exchange for being really fast and memory efficient, bloom filters trade off the fact that it can't tell you definitely if an item is in the set; it can only tell you definitely that item is <strong>not</strong> in the set. Stated differently, bloom filters have a false positive rate but do not have false negatives.</p>\n<p>Why is that useful? Sometimes you don't care about false positives, you just want to make sure something is <em>not</em> in the set. <a href=\"https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff\">Medium</a> has a great article on what they use bloom filters for: they use them to filter out articles they don't want to show you in their recommendations, whether those are items you've read before or things they've recommended too many times. What about that false positive rate? Well, they'll just filter out something they could have shown you and then show you something they definitely can show you. It's an acceptable trade off.</p>\n<p>Check out <a href=\"https://en.wikipedia.org/wiki/Bloom_filter#Examples\">Wikipedia</a> for some more examples of applications.</p>\n<p>So let's talk about how they work.</p>\n<p>Imagine you have an array with ten elements in it. Every element in the array is a <code class=\"language-text\">0</code> bit. This is an empty bloom filter. Now we want to add <code class=\"language-text\">&quot;Brian&quot;</code> to the array. I'm going to run <code class=\"language-text\">&quot;Brian&quot;</code> through three different hashing functions (see previous course for explanation on hashing functions.) Each hashing function should be <em>fast</em> and definitely not cryptographically secure (which are by-design slow.) This means <em>don't</em> use SHA or MD5. They should also have a uniform distribution as much as possible.</p>\n<p>Okay, so I run my string through three different hashing functions and they give me <code class=\"language-text\">2</code>, <code class=\"language-text\">5</code>, and <code class=\"language-text\">8</code> (I'm making up the numbers; we won't implement hashing functions so it doesn't really matter how they work.) I'll flip all those bits at those indexes so my new array is <code class=\"language-text\">[0, 0, 1, 0, 0, 1, 0, 0, 1, 0]</code>.</p>\n<p>After doing this, I'll check to see if <code class=\"language-text\">&quot;Sarah&quot;</code> is in the array. After running through the hashing function, they give <code class=\"language-text\">2</code>, <code class=\"language-text\">2</code>, and <code class=\"language-text\">4</code>. <code class=\"language-text\">2</code> is flipped but <code class=\"language-text\">4</code> is not, so I can definitively say that <code class=\"language-text\">&quot;Sarah&quot;</code> is not in the data set.</p>\n<p>So let's add one more item to the array, <code class=\"language-text\">&quot;Simona&quot;</code>. The indexes we get back <code class=\"language-text\">0</code>, <code class=\"language-text\">4</code>, and <code class=\"language-text\">5</code>. So now our array is <code class=\"language-text\">[1, 0, 1, 0, 1, 1, 0, 0, 1, 0]</code>. We flip both 0 and 4 indexes and 5 was already flipped so we do nothing to it. Now what happens if we check <code class=\"language-text\">&quot;Sarah&quot;</code> again? This time we'll get a false positive that <code class=\"language-text\">&quot;Sarah&quot;</code> is in the dataset. That's why the two answers you can get back from the question \"Is X in the bloom filter\" are no and maybe.</p>\n<p>That's it!</p>\n<p>So when you add more items to a bloom filter, you'll increase your false positive rate. You can mitigate this by having a larger array, but you'll be trading off on having a larger memory footprint. You can also have more or less hashing functions, trading off on how quickly memory will fill up versus false positive rates.</p>\n<h2 id=\"exercises\" style=\"position:relative;\"><a href=\"#exercises\" aria-label=\"exercises permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exercises</h2>\n<p><a href=\"https://codesandbox.io/s/algorithms-exercises-8kdjr?file=/specs/bloom-filters/bloom-filters.test.js\"><img src=\"https://codesandbox.io/static/img/play-codesandbox.svg\" alt=\"Edit algorithms-exercises\"></a></p>\n<p>We're going to work on <a href=\"https://github.com/btholt/algorithms-exercises/blob/main/specs/bloom-filters/bloom-filters.test.js\">/specs/bloom-filters/bloom-filters.test.js</a>. Go give that a shot.</p>","frontmatter":{"path":"/bloom-filters","title":"Bloom Filters","order":"10A","section":"Other Data Structures","description":""}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"7A","path":"/arraylist","title":"ArrayList"}}},{"node":{"frontmatter":{"order":"8B","path":"/avl-tree","title":"AVL Tree"}}},{"node":{"frontmatter":{"order":"2A","path":"/big-o","title":"Big O"}}},{"node":{"frontmatter":{"order":"8A","path":"/binary-search-tree","title":"Binary Search Tree"}}},{"node":{"frontmatter":{"order":"6A","path":"/binary-search","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10A","path":"/bloom-filters","title":"Bloom Filters"}}},{"node":{"frontmatter":{"order":"8D","path":"/breadth-first-tree-traversals","title":"Breadth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"3A","path":"/bubble-sort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"8C","path":"/depth-first-tree-traversals","title":"Depth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"1B","path":"/exercises","title":"The Exercises"}}},{"node":{"frontmatter":{"order":"9A","path":"/graphs","title":"Graphs"}}},{"node":{"frontmatter":{"order":"8E","path":"/heap-sort","title":"Heap Sort"}}},{"node":{"frontmatter":{"order":"3B","path":"/insertion-sort","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"7B","path":"/linkedlist","title":"LinkedList"}}},{"node":{"frontmatter":{"order":"4B","path":"/merge-sort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"9B","path":"/pathfinding","title":"Pathfinding"}}},{"node":{"frontmatter":{"order":"4C","path":"/quick-sort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5A","path":"/radix-sort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"4A","path":"/recursion","title":"Recursion"}}},{"node":{"frontmatter":{"order":"2B","path":"/spatial-complexity","title":"Spatial Complexity"}}},{"node":{"frontmatter":{"order":"2C","path":"/trade-offs","title":"Trade Offs"}}},{"node":{"frontmatter":{"order":"9C","path":"/tries","title":"Tries"}}},{"node":{"frontmatter":{"order":"11A","path":"/wrap-up","title":"Wrap Up"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}