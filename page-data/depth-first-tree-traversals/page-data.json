{"componentChunkName":"component---src-templates-lesson-template-js","path":"/depth-first-tree-traversals","result":{"data":{"markdownRemark":{"html":"<p>Trees are an essential part of storing data, or at computer scientists like to refer them as, data structures. Among their benefits is that they're optimized to be searchable. Occasionally you need to serialize the entire tree into a flat data structure. Today we'll show you how to do that.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 576px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/533c1/bst.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 83.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABTklEQVQ4y6WUW0vDQBCFv6a1GlQwrbR4qZdIjde2Vk2hWjXgi30QfJH+/18iW87CGuIu1IFlyWZycuacmYVwbAAXwCUQ84+oae8CV0AOHJTerRQ3wBiYAINVANaACGir1BaQaLWcM8OyGQIziUMx+ga2K3K2gAXwAIyAPR/gsXQaimFZr0i7ASmAKfBUpWvNSZxo7XoMMCwfgVcg9RmVqsxEbH1RVxudVb00pcyAU+fsWq0SapEO8A407MER0Afm7qHK+hCD/QDoXO4vqzoUs45KtbEDZBI+9TBtSM97AS/Bco1W5CQ21RovwPkfwtvnQqC3VtxN7eU/9yV85ik3kWzrJUK/3DPT8qVGR38uSqzqmvPP0LScaGZnumksizdJk6i1crk79vVhLMCRdLPT0pNpXZlo1rNaaxq6gXpyLHOSYo3jQO1kJLmTaW336x9DfhSEWbFJoQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary search tree\"\n        title=\"binary search tree\"\n        src=\"/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/533c1/bst.png\"\n        srcset=\"/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/772e8/bst.png 200w,\n/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/e17e5/bst.png 400w,\n/complete-intro-to-computer-science/static/8333499546d84a58751a5a12a8f34e9b/533c1/bst.png 576w\"\n        sizes=\"(max-width: 576px) 100vw, 576px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><sup>Public domain, via Wikimedia Commons</sup></p>\n<p>The picture tree is a valid binary search tree (BST.) We're going to show you four different ways serialization of this BST: three variations of depth-first traversal and one that is breadth-first traversal.</p>\n<h2 id=\"depth-first-traversal\" style=\"position:relative;\"><a href=\"#depth-first-traversal\" aria-label=\"depth first traversal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Depth-first Traversal</h2>\n<p>Let's start with one variant depth-first traversals: pre-order traversal. The basic gist is that for each of the nodes, you process the node (in our case, save it to an array since we're serializing this tree,) then process the left subtree and then the right tree. Let's write out that works.</p>\n<p>Given the above tree:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\n-&gt; Call our method (let&#39;s call it preorderTraverse) on the root node, 8.\n-&gt; Add 8 to our array.\n-&gt; Call preorderTraverse on the left child, 3.\n-&gt; Add 3 to our array.\n-&gt; Call preorderTraverse on the left child, 1.\n-&gt; Add 1 to our array.\n-&gt; Has no children, returns.\n-&gt; Going back up the tree, we&#39;ll call preorderTraverse on 6.\n-&gt; Add 6 to our array.\n-&gt; Call preorderTraverse on the left child, 4.\n-&gt; Add 4 to our array.\n-&gt; No children, returns.\n-&gt; Going back up the tree, we&#39;ll call preorderTraverse on 7.\n-&gt; Add 7 to the array.\n-&gt; So on and so forth.\n</code></pre></div>\n<p>We end up with the array of [8, 3, 1, 6, 4, 7, 10, 14, 13]. This is called preorder traversal.</p>\n<p>The other variants are quite similar; the only thing we do is change the order. When I say \"process the node,\" I mean you do whatever operation you're going to do: add it to an array, copy the node, or whatever that may be.</p>\n<p>In preorder traversal, you process the node, then recursively call the method on the left subtree and then the right subtree.</p>\n<p>In inorder traversal, you first recursively call the method on the left tree, then process the node, and then call the method on the right tree.</p>\n<p>Postorder traversal, as you have guessed, you recursively call the method on the left subtree, then the left subtree, then you process the node. The results of these are as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// preorder\n[8, 3, 1, 6, 4, 7, 10, 14, 13]\n\n// inorder\n[1, 3, 5, 6, 7, 8, 10, 13, 14]\n\n// postorder\n[1, 4, 7, 6, 3, 13, 14, 10, 8]</code></pre></div>\n<p>As you can see, it depends on what you're doing on which of these you use. For a sorted list out of a BST, you'd want to use inorder. If you're making a deep copy of a tree, preorder traversal is super useful since you'd copy a node, and then add its left child and then its right tree. Postorder would be useful if you're deleting a tree since you'd process the left tree, then the right, and only after the children had been deleted would you delete the node you're working on.</p>\n<p>So let's go give this a shot!</p>\n<h2 id=\"exercises\" style=\"position:relative;\"><a href=\"#exercises\" aria-label=\"exercises permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exercises</h2>\n<p><a href=\"https://codesandbox.io/s/algorithms-exercises-8kdjr?file=/specs/traversals/depth-first.test.js\"><img src=\"https://codesandbox.io/static/img/play-codesandbox.svg\" alt=\"Edit algorithms-exercises\"></a></p>\n<p>We're going to work on <a href=\"https://github.com/btholt/algorithms-exercises/blob/main/specs/traversals/depth-first.test.js\">/specs/traversals/depth-first.test.js</a>. Go give that a shot.</p>","frontmatter":{"path":"/depth-first-tree-traversals","title":"Depth-First Tree Traversals","order":"8C","section":"Trees","description":""}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"7A","path":"/arraylist","title":"ArrayList"}}},{"node":{"frontmatter":{"order":"8B","path":"/avl-tree","title":"AVL Tree"}}},{"node":{"frontmatter":{"order":"2A","path":"/big-o","title":"Big O"}}},{"node":{"frontmatter":{"order":"8A","path":"/binary-search-tree","title":"Binary Search Tree"}}},{"node":{"frontmatter":{"order":"6A","path":"/binary-search","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10A","path":"/bloom-filters","title":"Bloom Filters"}}},{"node":{"frontmatter":{"order":"8D","path":"/breadth-first-tree-traversals","title":"Breadth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"3A","path":"/bubble-sort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"8C","path":"/depth-first-tree-traversals","title":"Depth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"1B","path":"/exercises","title":"The Exercises"}}},{"node":{"frontmatter":{"order":"9A","path":"/graphs","title":"Graphs"}}},{"node":{"frontmatter":{"order":"8E","path":"/heap-sort","title":"Heap Sort"}}},{"node":{"frontmatter":{"order":"3B","path":"/insertion-sort","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"7B","path":"/linkedlist","title":"LinkedList"}}},{"node":{"frontmatter":{"order":"4B","path":"/merge-sort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"9B","path":"/pathfinding","title":"Pathfinding"}}},{"node":{"frontmatter":{"order":"4C","path":"/quick-sort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5A","path":"/radix-sort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"4A","path":"/recursion","title":"Recursion"}}},{"node":{"frontmatter":{"order":"2B","path":"/spatial-complexity","title":"Spatial Complexity"}}},{"node":{"frontmatter":{"order":"2C","path":"/trade-offs","title":"Trade Offs"}}},{"node":{"frontmatter":{"order":"9C","path":"/tries","title":"Tries"}}},{"node":{"frontmatter":{"order":"11A","path":"/wrap-up","title":"Wrap Up"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}