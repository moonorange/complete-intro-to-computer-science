{"componentChunkName":"component---src-templates-lesson-template-js","path":"/avl-tree","result":{"data":{"markdownRemark":{"html":"<p>AVL tree are the answer to the problem that BST have: BST can easily get out of balance. Even if it's not the worst case scenario of ascending or descending lists being added, even a random distribution on numbers on a BST is going to pretty heavy in places. There are several ways to balance these trees and we're going to tackle one of them: AVL trees. AVL is the initials of its authors: Georgy Adelson-Velsky and Evgenii Landis.</p>\n<p>AVLs are specialized BSTs. That is to say a valid AVL tree is always a valid BST (but not necessarily vice versa.) AVL trees are a subset of BST trees. When you add a new value to a AVL tree, you do it the same way. The only difference is on the way up your recursive calls you check to see if the node is balanced after you added the new node. A tree is out of balance if its subtrees' difference of heights is greater than one.\nDemonstrations of balanced and imbalanced AVL trees source: <a href=\"http://lcm.csa.iisc.ernet.in/dsa/node111.html\">http://lcm.csa.iisc.ernet.in/dsa/node111.html</a></p>\n<p>So what's the benefit of all this extra effort? We can now guarantee that we won't hit those bad or worst case scenarios of having greatly out-of-balance trees and guarantee we won't hit the O(n) cases. Our worst case becomes O(log n).</p>\n<h2 id=\"single-rotation\" style=\"position:relative;\"><a href=\"#single-rotation\" aria-label=\"single rotation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Single Rotation</h2>\n<p><video controls autoplay loop><source src=\"https://btholt.github.io/complete-intro-to-computer-science/avl-single-480.webm\" type=\"video/webm\"></video></p>\n<p><sup>VisuAlgo <a href=\"https://visualgo.net\">https://visualgo.net</a> – You may need to open this in Firefox, Chrome, or Edge to see the video above</sup></p>\n<p>So let's go through the hardest part of AVL trees, the rebalances (actually deletes may be harder but we're not going to do them!) The basic idea is that if one side of tree gets too heavy (i.e. the max height of one of its children is two more than the max height of the other child) then we need to perform a rotation to get the tree back in balance. Let's take a look at the most basic rotation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5\n \\\n  8\n\n-&gt; Currently valid AVL tree\n-&gt; .add called with 9\n\n5 - node A\n \\\n  8 - node B\n   \\\n    9 - node C\n\n(on the way up from the recursion)\n-&gt; check balance of node C: left height is 0, right height is 0, balanced\n-&gt; check balance of node B: left height is 0, right height is 1, balanced\n-&gt; check balance of node A: left height is 0, right height is 2\nunbalanced, right heavy, child is right heavy\n\n-&gt; perform right rotation\n-&gt; swap the values of nodes A and B\n-&gt; make node B the left child of node A\n-&gt; make node C the right child of node A\n-&gt; move node B&#39;s right child to its left child\n(in this case they&#39;re both null)\n-&gt; make node A&#39;s _original_ left child\n(which was null in this case) the left child of node B\n-&gt; update the heights of all the nodes involved\n\n      8 - node A\n    /   \\\n   5     9\nnode B   node C</code></pre></div>\n<p>This was a right rotation, but a left rotation is mirror of this. This generalized formula works for all but one case which we'll examine now.</p>\n<h2 id=\"double-rotations\" style=\"position:relative;\"><a href=\"#double-rotations\" aria-label=\"double rotations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Double Rotations</h2>\n<p><video controls autoplay loop><source src=\"https://btholt.github.io/complete-intro-to-computer-science/avl-double-480.webm\" type=\"video/webm\"></video></p>\n<p><sup>VisuAlgo <a href=\"https://visualgo.net\">https://visualgo.net</a> – You may need to open this in Firefox, Chrome, or Edge to see the video above</sup></p>\n<p>Even in this special case, all you have to do is perform an extra rotation which you already have the logic for.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5\n \\\n  8\n\n-&gt; currently valid AVL tree\n-&gt; .add called with 7\n\n5 - node A\n \\\n  8 - node B\n /\n7 - node C\n\n(on the way up from the recursion)\n-&gt; check balance of node C: left height is 0, right height is 0, balanced\n-&gt; check balance of node B: left height is 0, right height is 1, balanced\n-&gt; check balance of node A: left height is 0, right height is 2,\nunbalanced, right heavy, child is left heavy\n\nTry performing just a straight right rotation. It&#39;s not super helpful because you just end up with a still-unbalanced tree.\n\n  8 - node A&#39;\n /\n5 - node B&#39;\n \\\n  7 - node C&#39;</code></pre></div>\n<p>That's a problem, right? So now we have to what's called a double rotation. You perform a double rotation when the opposite child is heavy during a rotation. Look at our example (the 5\\8/7 example.) We're doing a right rotation but the left child of the right child is heavy (it's not out of balance, it's just heavier than the right child.) So what we're going to do is before we do a left rotation on the right child before we do a right rotation on the root node of the rotation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5 - node A\n \\\n  8 - node B\n /\n7 - node C\n\n[ ... previous steps ]\n-&gt; check balance of node A: left height is 0, right height is 2\nunbalanced - right heavy, child is left heavy\n-&gt; perform left rotation on left heavy right child node B\n\n5 - node A\n \\\n  7 - node B\n   \\\n    8 - node C\n\n-&gt; now perform right rotation on node A\n\n      7 - node A\n    /   \\\n   5     8\nnode B   node C</code></pre></div>\n<p>That's it! Nailing down the logic of those rotations is a pain but once you do AVL trees are just a series of either left or right rotations on a BST. Even deletes follow this pattern; it's just in deletes sometimes you have to do even more rotations.</p>\n<p>Want to see it in action yourself? Play around with <a href=\"https://visualgo.net/en/avl\">VisuAlgo</a>. It'll help you visualize further what you need to do.</p>\n<h2 id=\"exercises\" style=\"position:relative;\"><a href=\"#exercises\" aria-label=\"exercises permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exercises</h2>\n<p><a href=\"https://codesandbox.io/s/algorithms-exercises-8kdjr?file=/specs/avl/avl.test.js\"><img src=\"https://codesandbox.io/static/img/play-codesandbox.svg\" alt=\"Edit algorithms-exercises\"></a></p>\n<p>We're going to work on <a href=\"https://github.com/btholt/algorithms-exercises/blob/main/specs/avl/avl.test.js\">/specs/avl/avl.test.js</a>. Go give that a shot.</p>","frontmatter":{"path":"/avl-tree","title":"AVL Tree","order":"8B","section":"Trees","description":""}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"7A","path":"/arraylist","title":"ArrayList"}}},{"node":{"frontmatter":{"order":"8B","path":"/avl-tree","title":"AVL Tree"}}},{"node":{"frontmatter":{"order":"2A","path":"/big-o","title":"Big O"}}},{"node":{"frontmatter":{"order":"8A","path":"/binary-search-tree","title":"Binary Search Tree"}}},{"node":{"frontmatter":{"order":"6A","path":"/binary-search","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10A","path":"/bloom-filters","title":"Bloom Filters"}}},{"node":{"frontmatter":{"order":"8D","path":"/breadth-first-tree-traversals","title":"Breadth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"3A","path":"/bubble-sort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"8C","path":"/depth-first-tree-traversals","title":"Depth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"1B","path":"/exercises","title":"The Exercises"}}},{"node":{"frontmatter":{"order":"9A","path":"/graphs","title":"Graphs"}}},{"node":{"frontmatter":{"order":"8E","path":"/heap-sort","title":"Heap Sort"}}},{"node":{"frontmatter":{"order":"3B","path":"/insertion-sort","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"7B","path":"/linkedlist","title":"LinkedList"}}},{"node":{"frontmatter":{"order":"4B","path":"/merge-sort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"9B","path":"/pathfinding","title":"Pathfinding"}}},{"node":{"frontmatter":{"order":"4C","path":"/quick-sort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5A","path":"/radix-sort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"4A","path":"/recursion","title":"Recursion"}}},{"node":{"frontmatter":{"order":"2B","path":"/spatial-complexity","title":"Spatial Complexity"}}},{"node":{"frontmatter":{"order":"2C","path":"/trade-offs","title":"Trade Offs"}}},{"node":{"frontmatter":{"order":"9C","path":"/tries","title":"Tries"}}},{"node":{"frontmatter":{"order":"11A","path":"/wrap-up","title":"Wrap Up"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}