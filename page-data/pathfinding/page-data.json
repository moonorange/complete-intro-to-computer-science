{"componentChunkName":"component---src-templates-lesson-template-js","path":"/pathfinding","result":{"data":{"markdownRemark":{"html":"<p>Let's take what we've learned and go a step further. Imagine you have a 6 by 6 grid. You have point A at [1,1] and point B at [2,6]. ([0, 0] is top left.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">• • • • • •\n• A • • • •\n• • • • • •\n• • • • • •\n• • • • • •\n• • B • • •</code></pre></div>\n<p>How would you write code that finds the <em>shortest</em> path between A and B (no diagonals.) You could probably write some variant of looking to see if yA (the y of the A coordinate) is less than yB (y of the B coordinate). If it is, move one square from yA to yB. Rinse and repeat for the x axis. This works and given the current constraint will find you one of the shortest paths. It'd look something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">• • • • • •\n• A • • • •\n• 1 • • • •\n• 2 • • • •\n• 3 • • • •\n• 4 5 • • •</code></pre></div>\n<p>Now let's add a wall to the mix.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">• • • • • •\n• A • • • •\n• • • • • •\n• X X X X X\n• • • • • •\n• • B • • •</code></pre></div>\n<p>Suddenly our algorithm falls apart. You could probably devise some strategy to mitigate this but we can keep making more complicated wall structures to make it harder. So let's try something different: Dijkstra's algorithm.</p>\n<p>The basic gist of Dijkstra's algorithm is that we'll start at both the beginning and the end node and begin \"spiraling\" outwards, marking each node with how far away it is from from its original Node. We'll alternate spiraling one level with one node, and then one level with the other. After one iteration of the point A (doesn't matter if you start with the A or B) it'd look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">• 1 • • • •\n1 A 1 • • •\n• 1 • • • •\n• X X X X X\n• • • • • •\n• • B • • •</code></pre></div>\n<p>Then we'd do the same to point B which would like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">• 1 • • • •\n1 A 1 • • •\n• 1 • • • •\n• X X X X X\n• • 1 • • •\n• 1 B 1 • •</code></pre></div>\n<p>We'll do this until we intersect the two spirals. As soon as the spiral intersect we know we've found the shortest possible path. Let's keep going with point A:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2 1 2 • • •\n1 A 1 2 • •\n2 1 2 • • •\n• X X X X X\n• • 1 • • •\n• 1 B 1 • •</code></pre></div>\n<p>Notice this algorithm accounts for obstacles: if there's an obstacle, you just skip that node and keep going.</p>\n<p>Now point B:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2 1 2 • • •\n1 A 1 2 • •\n2 1 2 • • •\n• X X X X X\n• 2 1 2 • •\n2 1 B 1 2 •</code></pre></div>\n<p>You get the point, we alternate. So let's do the next steps for both point A and B.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2 1 2 3 • •\n1 A 1 2 3 •\n2 1 2 3 • •\n3 X X X X X\n3 2 1 2 3 •\n2 1 B 1 2 3</code></pre></div>\n<p>You can see they've intersected but our algorithm hasn't made that connection yet. But on the next iteration, as the spiraling is happening, those that point will see that the node it's going to has been marked by another origin point. Because of that, we know that we've found one of the shortest paths (there could be other paths that connect of the same length.) As such we've solved our problem: the shortest path is of length six. If you were keeping track of the nodes, you could give the coordinates of the path.</p>\n<p>So, given this as the basic gist, let's speak about the more technical details. The way to accomplish is <em>very</em> similar to what we just did with tree traversals. In fact it's literally the same algorithm applied a different way. Let's take point A and reimagine it as a tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">        A [1,1]\n     /  /     \\   \\\n[1,0] [0,1] [1,2] [2,1]\n/| |\\ /| |\\ /| |\\ /| |\\\n  [lots more children]</code></pre></div>\n<p>Instead of each node having at most two children like a binary search tree, each node has at most four children. Okay, now that we're thinking of this matrix as a tree, what we want to do is investigate first the nodes surrounding it, or in tree terms: its immediate children. We literally just learned how to do that with trees. It's breadth-first traversal! Let's apply the same secret algorithmic sauce to our problem here. We're going to take the root node (A) and add all of its children (neighbors, really) to a queue, and then begin processing each node as we pop them off the queue. Remember we need to alternate processing point A and point B, so we'll just alternate which ones we're pushing on the queue. Finally we'll have to keep track of visited nodes and distances, we'll just keep a duplicate matrix and mark it with what length it was and which origin point marked it. That's it!</p>\n<p>Technically what we're is actually breadth-first search, but the mechanics of Dijkstra's algorithm is the same and so the two are often conflated with each other. <a href=\"https://stackoverflow.com/questions/25449781/what-is-difference-between-bfs-and-dijkstras-algorithms-when-looking-for-shorte\">See here</a> for a more thorough explanation.</p>\n<p>If you want to see how this works using a visualizer, <a href=\"https://qiao.github.io/PathFinding.js/visual/\">check this out</a>.</p>\n<h2 id=\"exercises\" style=\"position:relative;\"><a href=\"#exercises\" aria-label=\"exercises permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exercises</h2>\n<p><a href=\"https://codesandbox.io/s/algorithms-exercises-8kdjr?file=/specs/pathfinding/pathfinding.test.js\"><img src=\"https://codesandbox.io/static/img/play-codesandbox.svg\" alt=\"Edit algorithms-exercises\"></a></p>\n<p>We're going to work on <a href=\"https://github.com/btholt/algorithms-exercises/blob/main/specs/pathfinding/pathfinding.test.js\">/specs/pathfinding/pathfinding.test.js</a>. Go give that a shot.</p>","frontmatter":{"path":"/pathfinding","title":"Pathfinding","order":"9B","section":"Applying Tree Algorithms","description":""}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"7A","path":"/arraylist","title":"ArrayList"}}},{"node":{"frontmatter":{"order":"8B","path":"/avl-tree","title":"AVL Tree"}}},{"node":{"frontmatter":{"order":"2A","path":"/big-o","title":"Big O"}}},{"node":{"frontmatter":{"order":"8A","path":"/binary-search-tree","title":"Binary Search Tree"}}},{"node":{"frontmatter":{"order":"6A","path":"/binary-search","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"10A","path":"/bloom-filters","title":"Bloom Filters"}}},{"node":{"frontmatter":{"order":"8D","path":"/breadth-first-tree-traversals","title":"Breadth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"3A","path":"/bubble-sort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"8C","path":"/depth-first-tree-traversals","title":"Depth-First Tree Traversals"}}},{"node":{"frontmatter":{"order":"1B","path":"/exercises","title":"The Exercises"}}},{"node":{"frontmatter":{"order":"9A","path":"/graphs","title":"Graphs"}}},{"node":{"frontmatter":{"order":"8E","path":"/heap-sort","title":"Heap Sort"}}},{"node":{"frontmatter":{"order":"3B","path":"/insertion-sort","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"1A","path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":"7B","path":"/linkedlist","title":"LinkedList"}}},{"node":{"frontmatter":{"order":"4B","path":"/merge-sort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"9B","path":"/pathfinding","title":"Pathfinding"}}},{"node":{"frontmatter":{"order":"4C","path":"/quick-sort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5A","path":"/radix-sort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"4A","path":"/recursion","title":"Recursion"}}},{"node":{"frontmatter":{"order":"2B","path":"/spatial-complexity","title":"Spatial Complexity"}}},{"node":{"frontmatter":{"order":"2C","path":"/trade-offs","title":"Trade Offs"}}},{"node":{"frontmatter":{"order":"9C","path":"/tries","title":"Tries"}}},{"node":{"frontmatter":{"order":"11A","path":"/wrap-up","title":"Wrap Up"}}}]}},"pageContext":{}},"staticQueryHashes":["2959687377"]}